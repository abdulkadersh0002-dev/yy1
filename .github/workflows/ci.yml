name: CI

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop

permissions:
  contents: read
  packages: write

jobs:
  lint-test:
    name: Lint & Test (Node ${{ matrix.node-version }})
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      matrix:
        node-version: ['20', '22']
    env:
      NODE_ENV: test
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run lint
        run: npm run lint

      - name: Run unit tests
        run: npm run test:unit

      - name: Run integration tests
        run: npm run test:integration

  quality:
    name: Quality & Delivery Checks
    needs: lint-test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      NODE_ENV: test
      IMAGE_TAG: signalsstrategy:${{ github.sha }}
      REGISTRY: ghcr.io
      REMOTE_IMAGE: ghcr.io/${{ github.repository }}:${{ github.sha }}
      PIPELINE_TEST_SUMMARY: lint,unit,integration,quality-gates
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install amtool
        run: |
          set -euo pipefail
          AM_VERSION="0.27.0"
          curl -fsSL -o alertmanager.tar.gz "https://github.com/prometheus/alertmanager/releases/download/v${AM_VERSION}/alertmanager-${AM_VERSION}.linux-amd64.tar.gz"
          tar -xzf alertmanager.tar.gz
          sudo mv "alertmanager-${AM_VERSION}.linux-amd64/amtool" /usr/local/bin/amtool
          sudo chmod +x /usr/local/bin/amtool

      - name: Run config quality gates
        run: npm run ci:quality-gates

      - name: Run lint
        run: npm run lint

      - name: Run unit tests
        run: npm run test:unit

      - name: Run integration tests
        run: npm run test:integration

      - name: Build Docker image
        run: docker build --build-arg NODE_ENV=production -t ${{ env.IMAGE_TAG }} .

      - name: Scan container image
        uses: aquasecurity/trivy-action@v0.16.0
        with:
          image-ref: ${{ env.IMAGE_TAG }}
          format: table
          vuln-type: 'os,library'
          severity: 'HIGH,CRITICAL'

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push image to GHCR
        run: |
          docker tag ${{ env.IMAGE_TAG }} ${{ env.REMOTE_IMAGE }}
          docker push ${{ env.REMOTE_IMAGE }}
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.REMOTE_IMAGE }})
          echo "IMAGE_DIGEST=${DIGEST}" >> $GITHUB_ENV

      - name: Create staging bundle
        run: npm run deploy:stage
        env:
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          DOCKER_IMAGE_TAG: ${{ env.REMOTE_IMAGE }}
          IMAGE_DIGEST: ${{ env.IMAGE_DIGEST }}

      - name: Upload staging bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: staging-bundle
          path: dist/staging
          if-no-files-found: error

      - name: Smoke test container
        run: |
          set -euxo pipefail
          trap 'docker rm -f signals-smoke || true' EXIT
          docker run -d --name signals-smoke \
            -e NODE_ENV=production \
            -e PORT=4101 \
            -e ALLOW_SYNTHETIC_DATA=true \
            -e REQUIRE_REALTIME_DATA=false \
            -e ENABLE_PREFETCH_SCHEDULER=false \
            -e AUTO_TRADING_AUTOSTART=false \
            -e ENABLE_WEBSOCKETS=false \
            -e ENABLE_RISK_REPORTS=false \
            -e ENABLE_PERFORMANCE_DIGESTS=false \
            -e ENABLE_BROKER_ROUTING=false \
            -e ENABLE_BROKER_OANDA=false \
            -e ENABLE_BROKER_MT5=false \
            -e ENABLE_BROKER_IBKR=false \
            -p 4101:4101 \
            ${{ env.REMOTE_IMAGE }}

          for attempt in {1..20}; do
            if curl -fsS http://127.0.0.1:4101/api/healthz > smoke-health.json; then
              cat smoke-health.json
              curl -fsS http://127.0.0.1:4101/api/health/modules > smoke-modules.json
              node - <<'NODE'
const fs = require('node:fs');
const payload = JSON.parse(fs.readFileSync('smoke-modules.json', 'utf8'));
if (!payload || typeof payload !== 'object' || typeof payload.modules !== 'object') {
  console.error('health/modules payload missing modules object');
  process.exit(1);
}
console.log('Health modules reported:', Object.keys(payload.modules));
NODE
              exit 0
            fi
            echo "Waiting for service to become healthy (attempt ${attempt})"
            sleep 5
          done

          echo "Service failed to become healthy"
          docker logs signals-smoke || true
          exit 1

      - name: Alertmanager smoke tests
        run: |
          set -euo pipefail

          export RUNBOOK_URL="https://docs.signalsstrategy.dev/runbooks/operational-provider-outage"

          PORT=18080
          OUTPUT=mock-alerts.json
          rm -f "$OUTPUT"

          node scripts/ci/mock-alert-receivers.mjs --port "$PORT" --output "$OUTPUT" &
          MOCK_PID=$!

          trap 'docker logs alerts-smoke || true; docker rm -f alerts-smoke || true; kill $MOCK_PID || true; wait $MOCK_PID || true' EXIT

          sleep 1

          export ALERTMANAGER_SLACK_WEBHOOK="http://127.0.0.1:${PORT}/slack/default"
          export ALERTMANAGER_SLACK_WEBHOOK_CRITICAL="http://127.0.0.1:${PORT}/slack/critical"
          export ALERTMANAGER_TICKETING_WEBHOOK="http://127.0.0.1:${PORT}/ticket"

          amtool check-config config/alertmanager/provider-availability-routing.yml

          docker run -d --name alerts-smoke \
            -p 9093:9093 \
            -e ALERTMANAGER_SLACK_WEBHOOK \
            -e ALERTMANAGER_SLACK_WEBHOOK_CRITICAL \
            -e ALERTMANAGER_TICKETING_WEBHOOK \
            -v "$PWD/config/alertmanager:/etc/alertmanager" \
            prom/alertmanager:v0.27.0 \
            --config.file=/etc/alertmanager/provider-availability-routing.yml \
            --log.level=debug

          for attempt in $(seq 1 20); do
            if curl -fsS http://127.0.0.1:9093/-/ready > /dev/null; then
              break
            fi
            sleep 1
          done

          amtool --alertmanager.url=http://127.0.0.1:9093 alert add ProviderAvailabilityCritical \
            service=signals-app \
            severity=critical \
            summary="CI smoke test" \
            description="CI verification for provider availability routing" \
            runbook="${RUNBOOK_URL}"

          sleep 2

          node - <<'NODE'
const http = require('node:http');

function fetchAlerts() {
  return new Promise((resolve, reject) => {
    const req = http.get('http://127.0.0.1:9093/api/v2/alerts', (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        try {
          const payload = JSON.parse(Buffer.concat(chunks).toString('utf8'));
          resolve(payload);
        } catch (error) {
          reject(error);
        }
      });
    });
    req.on('error', reject);
  });
}

const EXPECTED_ALERT = {
  alertname: 'ProviderAvailabilityCritical',
  service: 'signals-app',
  severity: 'critical'
};

fetchAlerts()
  .then((alerts) => {
    if (!Array.isArray(alerts) || alerts.length === 0) {
      throw new Error('Alertmanager returned no active alerts');
    }
    const active = alerts.find((entry) => {
      const labels = entry?.labels || {};
      return labels.alertname === EXPECTED_ALERT.alertname
        && labels.service === EXPECTED_ALERT.service
        && labels.severity === EXPECTED_ALERT.severity;
    });
    if (!active) {
      throw new Error('Expected provider availability alert not found in Alertmanager payload');
    }
    const receivers = active.receivers || [];
    const targets = Array.isArray(receivers) ? receivers.map((item) => item.name) : [];
    if (!targets.includes('signals-critical')) {
      throw new Error(`Expected alert to route to signals-critical receiver, got: ${targets.join(',')}`);
    }
    if (!active.annotations || !active.annotations.runbook) {
      throw new Error('Alert annotations missing runbook link');
    }
    return null;
  })
  .catch((error) => {
    console.error(error.message || error);
    process.exit(1);
  });
NODE

          amtool --alertmanager.url=http://127.0.0.1:9093 alert expire ProviderAvailabilityCritical service=signals-app severity=critical || true

          sleep 2

          node - <<'NODE'
const http = require('node:http');

function fetchAlerts() {
  return new Promise((resolve, reject) => {
    const req = http.get('http://127.0.0.1:9093/api/v2/alerts', (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        try {
          const payload = JSON.parse(Buffer.concat(chunks).toString('utf8'));
          resolve(payload);
        } catch (error) {
          reject(error);
        }
      });
    });
    req.on('error', reject);
  });
}

fetchAlerts()
  .then((alerts) => {
    if (Array.isArray(alerts) && alerts.length === 0) {
      return null;
    }
    throw new Error('Expected Alertmanager to have no active alerts after expiration');
  })
  .catch((error) => {
    console.error(error.message || error);
    process.exit(1);
  });
NODE

          amtool --alertmanager.url=http://127.0.0.1:9093 alert add ProviderAvailabilityDegraded \
            service=signals-app \
            severity=warning \
            summary="CI smoke test (warning)" \
            description="CI verification for warning routing" \
            runbook="${RUNBOOK_URL}"

          sleep 2

          node - <<'NODE'
const http = require('node:http');

function fetchAlerts() {
  return new Promise((resolve, reject) => {
    const req = http.get('http://127.0.0.1:9093/api/v2/alerts', (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        try {
          const payload = JSON.parse(Buffer.concat(chunks).toString('utf8'));
          resolve(payload);
        } catch (error) {
          reject(error);
        }
      });
    });
    req.on('error', reject);
  });
}

const EXPECTED_ALERT = {
  alertname: 'ProviderAvailabilityDegraded',
  service: 'signals-app',
  severity: 'warning'
};

fetchAlerts()
  .then((alerts) => {
    if (!Array.isArray(alerts) || alerts.length === 0) {
      throw new Error('Expected warning alert to be active, but none were returned');
    }
    const active = alerts.find((entry) => {
      const labels = entry?.labels || {};
      return labels.alertname === EXPECTED_ALERT.alertname
        && labels.service === EXPECTED_ALERT.service
        && labels.severity === EXPECTED_ALERT.severity;
    });
    if (!active) {
      throw new Error('Warning alert not present in Alertmanager payload');
    }
    const receivers = active.receivers || [];
    const targets = Array.isArray(receivers) ? receivers.map((item) => item.name) : [];
    if (!targets.includes('signals-warning')) {
      throw new Error(`Expected warning alert to route to signals-warning receiver, got: ${targets.join(',')}`);
    }
    if (!active.annotations || !active.annotations.runbook) {
      throw new Error('Warning alert missing runbook annotation');
    }
    return null;
  })
  .catch((error) => {
    console.error(error.message || error);
    process.exit(1);
  });
NODE

          node - <<'NODE'
const fs = require('node:fs');

const payloadPath = 'mock-alerts.json';
if (!fs.existsSync(payloadPath)) {
  throw new Error('Mock alert payload file not found');
}

const entries = JSON.parse(fs.readFileSync(payloadPath, 'utf8'));
if (!Array.isArray(entries) || entries.length === 0) {
  throw new Error('No mock alert receiver payloads captured');
}

const slack = entries.find((entry) => typeof entry.path === 'string' && entry.path.includes('/slack/critical'));
if (!slack) {
  throw new Error('Critical Slack webhook was not invoked');
}

const slackText = slack.bodyJson?.text;
const expectedRunbook = process.env.RUNBOOK_URL || 'https://docs.signalsstrategy.dev/runbooks/operational-provider-outage';
if (typeof slackText !== 'string' || !slackText.includes('ProviderAvailabilityCritical') || !slackText.includes(expectedRunbook)) {
  throw new Error('Slack payload missing expected alert text or runbook');
}

const ticket = entries.find((entry) => typeof entry.path === 'string' && entry.path.includes('/ticket'));
if (!ticket) {
  throw new Error('Ticket webhook was not invoked');
}

const ticketPayload = ticket.bodyJson;
if (!ticketPayload || !Array.isArray(ticketPayload.alerts) || ticketPayload.alerts.length === 0) {
  throw new Error('Ticket webhook payload missing alerts array');
}

const alert = ticketPayload.alerts[0];
if (alert.labels?.alertname !== 'ProviderAvailabilityCritical') {
  throw new Error('Ticket webhook payload missing expected alertname label');
}
if (alert.labels?.service !== 'signals-app') {
  throw new Error('Ticket webhook payload missing expected service label');
}
if (alert.annotations?.runbook !== expectedRunbook) {
  throw new Error('Ticket webhook payload missing runbook annotation');
}
if (ticketPayload.receiver !== 'signals-critical') {
  throw new Error(`Ticket webhook routed to unexpected receiver: ${ticketPayload.receiver}`);
}
NODE

          node - <<'NODE'
const fs = require('node:fs');

const payloadPath = 'mock-alerts.json';
const entries = JSON.parse(fs.readFileSync(payloadPath, 'utf8'));

const warningSlack = entries.find((entry) => typeof entry.path === 'string' && entry.path.includes('/slack/default'));
if (!warningSlack) {
  throw new Error('Warning Slack webhook was not invoked');
}

const payload = warningSlack.bodyJson;
if (!payload || typeof payload.text !== 'string') {
  throw new Error('Warning Slack payload missing text body');
}

if (!payload.text.includes('ProviderAvailabilityDegraded')) {
  throw new Error('Warning Slack payload missing alert name');
}

if (!payload.text.includes('*Severity*: warning')) {
  throw new Error('Warning Slack payload missing severity line');
}

if (payload.channel !== '#signals-ops') {
  throw new Error(`Warning Slack payload routed to unexpected channel: ${payload.channel}`);
}
NODE

          amtool --alertmanager.url=http://127.0.0.1:9093 alert expire ProviderAvailabilityDegraded service=signals-app severity=warning || true

          sleep 2

          node - <<'NODE'
const http = require('node:http');

function fetchAlerts() {
  return new Promise((resolve, reject) => {
    const req = http.get('http://127.0.0.1:9093/api/v2/alerts', (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        try {
          const payload = JSON.parse(Buffer.concat(chunks).toString('utf8'));
          resolve(payload);
        } catch (error) {
          reject(error);
        }
      });
    });
    req.on('error', reject);
  });
}

fetchAlerts()
  .then((alerts) => {
    if (Array.isArray(alerts) && alerts.length === 0) {
      return null;
    }
    throw new Error('Expected Alertmanager to have no active alerts after warning expiration');
  })
  .catch((error) => {
    console.error(error.message || error);
    process.exit(1);
  });
NODE

          node - <<'NODE'
const fs = require('node:fs');

const payloadPath = 'mock-alerts.json';
if (!fs.existsSync(payloadPath)) {
  throw new Error('Mock alert payload file not found when validating recovery notifications');
}

const entries = JSON.parse(fs.readFileSync(payloadPath, 'utf8'));

function findResolvedSlack(pathFragment) {
  const match = [...entries]
    .reverse()
    .find((entry) => typeof entry.path === 'string'
      && entry.path.includes(pathFragment)
      && typeof entry.bodyJson === 'object'
      && typeof entry.bodyJson.text === 'string'
      && entry.bodyJson.text.toLowerCase().includes('resolved'));
  if (!match) {
    throw new Error(`Resolved Slack notification missing for ${pathFragment}`);
  }
}

function assertTicketResolved(pathFragment) {
  const match = [...entries]
    .reverse()
    .find((entry) => typeof entry.path === 'string'
      && entry.path.includes(pathFragment)
      && typeof entry.bodyJson === 'object'
      && (entry.bodyJson.status === 'resolved'
        || (Array.isArray(entry.bodyJson.alerts)
          && entry.bodyJson.alerts.some((alert) => alert.status === 'resolved'))));
  if (!match) {
    throw new Error(`Resolved ticket webhook missing or lacks resolved status for ${pathFragment}`);
  }
}

findResolvedSlack('/slack/critical');
findResolvedSlack('/slack/default');
assertTicketResolved('/ticket');
NODE

          critical_firing_before=$(node - <<'NODE'
const fs = require('node:fs');

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));
const count = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/critical')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING')).length;
process.stdout.write(String(count));
NODE
)

          critical_resolved_before=$(node - <<'NODE'
const fs = require('node:fs');

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));
const count = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/critical')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED')).length;
process.stdout.write(String(count));
NODE
)

          ticket_firing_before=$(node - <<'NODE'
const fs = require('node:fs');

function isResolved(payload) {
  if (!payload || typeof payload !== 'object') {
    return false;
  }
  if (typeof payload.status === 'string' && payload.status.toLowerCase() === 'resolved') {
    return true;
  }
  if (Array.isArray(payload.alerts)) {
    return payload.alerts.some((alert) => alert && typeof alert.status === 'string' && alert.status.toLowerCase() === 'resolved');
  }
  return false;
}

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));
const count = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/ticket')
  && entry.bodyJson
  && !isResolved(entry.bodyJson)).length;
process.stdout.write(String(count));
NODE
)

          ticket_resolved_before=$(node - <<'NODE'
const fs = require('node:fs');

function isResolved(payload) {
  if (!payload || typeof payload !== 'object') {
    return false;
  }
  if (typeof payload.status === 'string' && payload.status.toLowerCase() === 'resolved') {
    return true;
  }
  if (Array.isArray(payload.alerts)) {
    return payload.alerts.some((alert) => alert && typeof alert.status === 'string' && alert.status.toLowerCase() === 'resolved');
  }
  return false;
}

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));
const count = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/ticket')
  && entry.bodyJson
  && isResolved(entry.bodyJson)).length;
process.stdout.write(String(count));
NODE
)

          amtool --alertmanager.url=http://127.0.0.1:9093 alert add ProviderAvailabilityCritical \
            service=signals-app \
            severity=critical \
            summary="CI flapping test" \
            description="CI verification for repeated fire/resolution" \
            runbook="${RUNBOOK_URL}"

          sleep 1

          amtool --alertmanager.url=http://127.0.0.1:9093 alert add ProviderAvailabilityCritical \
            service=signals-app \
            severity=critical \
            summary="CI flapping duplicate" \
            description="Duplicate fire to check dedupe" \
            runbook="${RUNBOOK_URL}"

          sleep 2

          amtool --alertmanager.url=http://127.0.0.1:9093 alert expire ProviderAvailabilityCritical service=signals-app severity=critical || true

          sleep 2

          export CRIT_FIRE_BEFORE="$critical_firing_before"
          export CRIT_RES_BEFORE="$critical_resolved_before"
          export TICKET_FIRE_BEFORE="$ticket_firing_before"
          export TICKET_RES_BEFORE="$ticket_resolved_before"

          node - <<'NODE'
const fs = require('node:fs');

function isResolved(payload) {
  if (!payload || typeof payload !== 'object') {
    return false;
  }
  if (typeof payload.status === 'string' && payload.status.toLowerCase() === 'resolved') {
    return true;
  }
  if (Array.isArray(payload.alerts)) {
    return payload.alerts.some((alert) => alert && typeof alert.status === 'string' && alert.status.toLowerCase() === 'resolved');
  }
  return false;
}

function findLastIndex(arr, predicate) {
  for (let index = arr.length - 1; index >= 0; index -= 1) {
    if (predicate(arr[index], index)) {
      return index;
    }
  }
  return -1;
}

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));

const criticalFiring = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/critical')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING')).length;

const criticalResolved = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/critical')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED')).length;

const ticketFiring = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/ticket')
  && entry.bodyJson
  && !isResolved(entry.bodyJson)).length;

const ticketResolved = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/ticket')
  && entry.bodyJson
  && isResolved(entry.bodyJson)).length;

const criticalFiringExpected = Number(process.env.CRIT_FIRE_BEFORE) + 1;
const criticalResolvedExpected = Number(process.env.CRIT_RES_BEFORE) + 1;
const ticketFiringExpected = Number(process.env.TICKET_FIRE_BEFORE) + 1;
const ticketResolvedExpected = Number(process.env.TICKET_RES_BEFORE) + 1;

if (criticalFiring !== criticalFiringExpected) {
  throw new Error(`Expected one new critical firing notification during flapping cycle but saw ${criticalFiring - Number(process.env.CRIT_FIRE_BEFORE)}`);
}

if (criticalResolved !== criticalResolvedExpected) {
  throw new Error('Critical resolved notifications did not record the flapping recovery');
}

if (ticketFiring !== ticketFiringExpected) {
  throw new Error('Ticket webhook firing notifications count mismatch during the flapping cycle');
}

if (ticketResolved !== ticketResolvedExpected) {
  throw new Error('Ticket webhook resolved payload missing for flapping cycle');
}

const lastCriticalFiringIndex = findLastIndex(entries, (entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/critical')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING'));

const lastCriticalResolvedIndex = findLastIndex(entries, (entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/critical')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED'));

if (lastCriticalResolvedIndex <= lastCriticalFiringIndex) {
  throw new Error('Latest critical resolved notification should land after the corresponding firing notification');
}

const lastTicketResolvedIndex = findLastIndex(entries, (entry) => typeof entry.path === 'string'
  && entry.path.includes('/ticket')
  && entry.bodyJson
  && isResolved(entry.bodyJson));

const lastTicketFiringIndex = findLastIndex(entries, (entry) => typeof entry.path === 'string'
  && entry.path.includes('/ticket')
  && entry.bodyJson
  && !isResolved(entry.bodyJson));

if (lastTicketResolvedIndex <= lastTicketFiringIndex) {
  throw new Error('Ticket resolved payload did not arrive after the flapping firing payload');
}

NODE

          warning_firing_before=$(node - <<'NODE'
const fs = require('node:fs');

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));
const count = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING')).length;
process.stdout.write(String(count));
NODE
)

          warning_resolved_before=$(node - <<'NODE'
const fs = require('node:fs');

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));
const count = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED')).length;
process.stdout.write(String(count));
NODE
)

          amtool --alertmanager.url=http://127.0.0.1:9093 alert add ProviderAvailabilityDegraded \
            service=signals-app \
            severity=warning \
            summary="CI flapping test (warning)" \
            description="CI verification for repeated warning fire/resolution" \
            runbook="${RUNBOOK_URL}"

          sleep 1

          amtool --alertmanager.url=http://127.0.0.1:9093 alert add ProviderAvailabilityDegraded \
            service=signals-app \
            severity=warning \
            summary="CI flapping duplicate (warning)" \
            description="Duplicate warning fire to check dedupe" \
            runbook="${RUNBOOK_URL}"

          sleep 2

          amtool --alertmanager.url=http://127.0.0.1:9093 alert expire ProviderAvailabilityDegraded service=signals-app severity=warning || true

          sleep 2

          export WARN_FIRE_BEFORE="$warning_firing_before"
          export WARN_RES_BEFORE="$warning_resolved_before"

          node - <<'NODE'
const fs = require('node:fs');

function findLastIndex(arr, predicate) {
  for (let index = arr.length - 1; index >= 0; index -= 1) {
    if (predicate(arr[index], index)) {
      return index;
    }
  }
  return -1;
}

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));

const warningFiring = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING')).length;

const warningResolved = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED')).length;

const warningFiringExpected = Number(process.env.WARN_FIRE_BEFORE) + 1;
const warningResolvedExpected = Number(process.env.WARN_RES_BEFORE) + 1;

if (warningFiring !== warningFiringExpected) {
  throw new Error('Warning Slack route firing notification count mismatch during flapping test');
}

if (warningResolved !== warningResolvedExpected) {
  throw new Error('Warning Slack route missed resolved notification during flapping test');
}

const lastWarningFiringIndex = findLastIndex(entries, (entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING'));

const lastWarningResolvedIndex = findLastIndex(entries, (entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED'));

if (lastWarningResolvedIndex <= lastWarningFiringIndex) {
  throw new Error('Warning Slack resolved payload did not follow the firing notification during flapping test');
}

NODE

          node - <<'NODE'
const http = require('node:http');

function fetchAlerts() {
  return new Promise((resolve, reject) => {
    const req = http.get('http://127.0.0.1:9093/api/v2/alerts', (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        try {
          const payload = JSON.parse(Buffer.concat(chunks).toString('utf8'));
          resolve(payload);
        } catch (error) {
          reject(error);
        }
      });
    });
    req.on('error', reject);
  });
}

fetchAlerts()
  .then((alerts) => {
    if (!Array.isArray(alerts) || alerts.length === 0) {
      return null;
    }
    throw new Error('Expected no active alerts after flapping regression cycle completed');
  })
  .catch((error) => {
    console.error(error.message || error);
    process.exit(1);
  });
NODE

          slo_warning_firing_before=$(node - <<'NODE'
const fs = require('node:fs');

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));
const count = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING')).length;
process.stdout.write(String(count));
NODE
)

          slo_warning_resolved_before=$(node - <<'NODE'
const fs = require('node:fs');

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));
const count = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED')).length;
process.stdout.write(String(count));
NODE
)

          export SLO_WARN_FIRE_BEFORE="$slo_warning_firing_before"
          export SLO_WARN_RES_BEFORE="$slo_warning_resolved_before"

          amtool --alertmanager.url=http://127.0.0.1:9093 alert add ProviderAvailabilityUptimeSLOBreached \
            service=signals-app \
            severity=warning \
            summary="CI SLO breach test" \
            description="CI verification for uptime SLO breach routing" \
            runbook="${RUNBOOK_URL}"

          sleep 2

          node - <<'NODE'
const fs = require('node:fs');

function findLastIndex(arr, predicate) {
  for (let index = arr.length - 1; index >= 0; index -= 1) {
    if (predicate(arr[index], index)) {
      return index;
    }
  }
  return -1;
}

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));

const warningFiring = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING')).length;

const expectedFiring = Number(process.env.SLO_WARN_FIRE_BEFORE) + 1;
if (warningFiring !== expectedFiring) {
  throw new Error('SLO breach firing notification count mismatch');
}

const lastFiringIndex = findLastIndex(entries, (entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: FIRING'));

if (lastFiringIndex < 0) {
  throw new Error('Failed to locate SLO breach firing payload');
}

const firingPayload = entries[lastFiringIndex]?.bodyJson || {};
if (typeof firingPayload.title !== 'string' || !firingPayload.title.includes('ProviderAvailabilityUptimeSLOBreached')) {
  throw new Error('SLO breach Slack payload missing alert name in title');
}

if (typeof firingPayload.text !== 'string' || !firingPayload.text.includes('operational-provider-outage')) {
  throw new Error('SLO breach Slack payload missing runbook reference');
}

if (!firingPayload.text.toUpperCase().includes('*STATE*: FIRING')) {
  throw new Error('SLO breach Slack payload missing firing state annotation');
}
NODE

          amtool --alertmanager.url=http://127.0.0.1:9093 alert expire ProviderAvailabilityUptimeSLOBreached service=signals-app severity=warning || true

          sleep 2

          node - <<'NODE'
const fs = require('node:fs');

function findLastIndex(arr, predicate) {
  for (let index = arr.length - 1; index >= 0; index -= 1) {
    if (predicate(arr[index], index)) {
      return index;
    }
  }
  return -1;
}

const entries = JSON.parse(fs.readFileSync('mock-alerts.json', 'utf8'));

const warningResolved = entries.filter((entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED')).length;

const expectedResolved = Number(process.env.SLO_WARN_RES_BEFORE) + 1;
if (warningResolved !== expectedResolved) {
  throw new Error('SLO breach resolved notification count mismatch');
}

const lastResolvedIndex = findLastIndex(entries, (entry) => typeof entry.path === 'string'
  && entry.path.includes('/slack/default')
  && entry.bodyJson
  && typeof entry.bodyJson.text === 'string'
  && entry.bodyJson.text.toUpperCase().includes('*STATE*: RESOLVED'));

if (lastResolvedIndex < 0) {
  throw new Error('Failed to locate SLO breach resolved payload');
}

const resolvedPayload = entries[lastResolvedIndex]?.bodyJson || {};

if (typeof resolvedPayload.text !== 'string' || !resolvedPayload.text.toUpperCase().includes('*STATE*: RESOLVED')) {
  throw new Error('SLO breach resolved payload missing resolved state annotation');
}

if (typeof resolvedPayload.text !== 'string' || !resolvedPayload.text.includes('operational-provider-outage')) {
  throw new Error('SLO breach resolved payload missing runbook reference');
}

if (typeof resolvedPayload.title !== 'string' || !resolvedPayload.title.includes('ProviderAvailabilityUptimeSLOBreached')) {
  throw new Error('SLO breach resolved payload missing alert name in title');
}
NODE

          node - <<'NODE'
const http = require('node:http');

function fetchAlerts() {
  return new Promise((resolve, reject) => {
    const req = http.get('http://127.0.0.1:9093/api/v2/alerts', (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        try {
          const payload = JSON.parse(Buffer.concat(chunks).toString('utf8'));
          resolve(payload);
        } catch (error) {
          reject(error);
        }
      });
    });
    req.on('error', reject);
  });
}

fetchAlerts()
  .then((alerts) => {
    if (!Array.isArray(alerts) || alerts.length === 0) {
      return null;
    }
    throw new Error('Expected no active alerts after SLO breach regression cycle completed');
  })
  .catch((error) => {
    console.error(error.message || error);
    process.exit(1);
  });
NODE

          node scripts/ci/compare-alert-snapshots.mjs --input "$OUTPUT" --fixtures "scripts/ci/fixtures/alertmanager"

          node scripts/ci/check-runbook-links.mjs --input "$OUTPUT" --timeout-ms 10000

          kill $MOCK_PID || true
          wait $MOCK_PID || true

          if [ -f "$OUTPUT" ]; then
            gzip -f "$OUTPUT"
          fi

      - name: Upload alert payload artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: alertmanager-payloads
          path: mock-alerts.json.gz
          if-no-files-found: warn
